---
title: "Projet en atelier statistique avec R"
subtitle: "Analyse de l Impact des Performances des Joueurs sur les Résultats d equipe"
author: "Yassine Hammi"
date: "2024-11-26"

output: 
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 6
    keep_tex: true
    number_sections: true
    fig_caption: true
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
  - \RecustomVerbatimEnvironment{verbatim}{Verbatim}{breaklines,commandchars=\\\{\}}
  - \renewcommand{\baselinestretch}{1.1}
lang: fr
fontsize: 6pt
geometry: top=2cm,bottom=2cm,right=2.5cm,left=2.5cm
  
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Dans le domaine sportif, la performance individuelle des joueurs peut influencer directement ou indirectement les résultats globaux de leur équipe. Cependant, comprendre précisément cette relation reste un défi.

Quels sont les facteurs clés individuelle qui influencent les performances collectives ? Quels types de joueurs ont un rôle déterminant sur les victoires ou les défaites? Cette analyse est essentielle pour optimiser la gestion des équipes et améliorer leurs performances.

Pour commencer, nous allons aborder la question d'exploration fondamentale, qui sera le point de départ de notre analyse à travers les différentes étapes. Nous permettant de spécifier les variables clés à observer, de collecter des données exhaustives, de les prétraiter avec rigueur, d'effectuer une analyse approfondie et enfin de présenter des résultats interprétables.


## Question principale d'exploration

Comment les performances individuelles des joueurs influencent-elles les résultats et la performance globale de leur équipe ?

En examinant de près les principales raisons, nous espérons obtenir une meilleure compréhension sur les perforamnces pour chaque joueur individuelle et comme conséquences la performance d'equipe et comment cela influence l'echec ou la reussite de l'equipe.

## Spécification des Variables
Pour mener à bien notre analyse, nous nous appuierons sur differents sources de données cruciales telque “Performance des joueurs individuels” et leur “Resultats des matchs", "Performance collective"



# Collecte de Données
Collection de données s’agit d’une étape cruciale pour l’ensemble du projet, tant que nous disposons de données bien structurés, nous pouvons effectuer une meilleure analyse plus approfondie. 

il est important d'identifier notre sources de données

## Identification 

* Kaggle: as the world's largest data science community with powerful tools and resources to help us achieve our data science goals and objectifs.

* Github : nous pouvons trouver plusieurs projets open source concernant le football, avec des données mises à jour sur les joueurs et les équipes.
 

## Importation

Au début de notre analyse, nous commençons par intégrer les données essentielles à partir des sources distincts.

```{r Importation des données partie1, message=FALSE, warning=FALSE, out.width='80%', results='hold'}
# Installation de package si n'existe pas 
if (!require(readr) ) {install.packages("readr" , repos = "http://cran.us.r-project.org")}

# Chargement de package 
library(readr)
library(knitr)


# Importation de donneés depuis fichier excel 
# Cette fichier est importé depuis kaggle
# Comporte les donneés de championnat d'Espagne de football de première division

LaLigaPlayers <- read_csv("C:/Users/21655/Desktop/Projet_DS_Yassine/Data/S2324-laliga-players.csv")
# Dimension de notre dataset 
dim(LaLigaPlayers) # 3615 lignes , 150 columns 
# Affichage de dooneés 
kable(head(LaLigaPlayers[,7:13],6),caption = "LaLiga - sample 6 lignes avec 7 columns")

```

```{r Importation des données partie12, message=FALSE, warning=FALSE, out.width='80%', results='hold'}
# Chargement de package pour extraire des données depuis l'internet 
library(rvest)
 
# Le lien d’où allons extraire les informations d'une equipe
# Dans ce cas nous avons choisis l'equipe "Real Madrid" 
link <-"https://fbref.com/fr/equipes/53a2f082/2023-2024/Statistiques-Real-Madrid"

page <- read_html(link,header=FALSE)

# Nous avons extrait les tables dans cette page 
tables <- page %>%
  html_nodes("table") %>%
  html_table(fill = TRUE)

# Mettre le deuxième tableau dans notre dataset MatchesRM
if(length(tables)>0){
  MatchesRM <- tables[[2]]
  dim(MatchesRM)  # 55 lignes , 20 columns 
  kable(head(MatchesRM[,4:13],6),caption="Matches-RM") 
} else {
  print("aucun table trouveé")
}
```


# PreProcessing 

## Suppression des colonnes dans la première dataset : RealMadridPlayers

```{r Column Suppression, message=FALSE, warning=FALSE, out.width='80%', results='hold'}

# Suppression des colonnes inutiles dans notre jeu de données
# Nous avons déjà supprimér plusieurs colonnes mais nous venons de laisser celles-ci comme exemple de code 

LaLigaPlayers <- subset(LaLigaPlayers,select=-c(height, weight, competition ,player.url ,id ,date_of_birth , country ,place_of_birth , slug ,nickname, firstname, lastname, gender, international, throw_ins_to_opposition_player ,throw_ins_to_own_player ,twitter ,instagram ,team.shortname ,team.foundation ,team.shield ,photo ,stadium ,stadium.image ,drops ,games_played ,goalkeeper_smother ,hit_woodwork ,index ,last_player_tackle ,left_foot_goals ,leftside_passes ,other_goals ,punches ,right_foot_goals ,rightside_passes ,shots_off_target_inc_woodwork ,team_games_played ,handballs_conceded ) )

# Conserver seulement les joueurs de Real Madrid à partir de dataset LaLigaPlayers

library(kableExtra)
RealMadridPlayers <- subset(LaLigaPlayers, LaLigaPlayers$team=="Real Madrid")

RealMadridPlayers <- subset(RealMadridPlayers,select = -c(team))

kable(
    head( RealMadridPlayers[,1:7],6 ),
    caption = "Tableau des Données 1er 6 lignes avec 7 colonnes",
    format = "latex", 
    booktabs = TRUE,  # Ajouter des traits horizontaux propres
    align = "c"    # Centrer les colonnes
  ) %>%
    kable_styling(
      latex_options = c("striped", "hold_position"),  # Style rayé et position maintenue
      full_width = TRUE,  # Table non étendue à la largeur complète
      font_size = 7
    )

#kable(head (RealMadridPlayers[,1:9],6),caption = " Joueurs RM") 



print( paste("Dimension : ", dim(RealMadridPlayers)) ) # 175 lignes , 112 columns
print( paste("Nombre de lignes : ",nrow(RealMadridPlayers)))  # nous avons 175 lignes 

```

## Suppression les lignes redundantes dans la première dataset : RealMadridPlayers

```{r Duplicates Suppression, message=FALSE, warning=FALSE, out.width='80%', results='hold'}

# Nombres duplicates
num_duplicates <- sum(duplicated(RealMadridPlayers))

# Identifer les lignes dupliquées. 

duplicated_RM_Players <- RealMadridPlayers[duplicated(RealMadridPlayers),]
# les enregistrements dupliquées = 140
head(duplicated_RM_Players, n =15)
```

```{r Duplicates Suppression2, message=FALSE, warning=FALSE, out.width='80%', results='hold'}



# Les lignes nettoyées sur lesquelles nous allons travailler  
normaldt_RM_Players <- RealMadridPlayers[!duplicated(RealMadridPlayers),]


kable(
    head( normaldt_RM_Players[,1:7],6 ),
    caption = "Tableau des Données 1er 6 lignes avec 7 colonnes",
    format = "latex", 
    booktabs = TRUE,  # Ajouter des traits horizontaux propres
    align = "c"    # Centrer les colonnes
  ) %>%
    kable_styling(
      latex_options = c("striped", "hold_position"),  # Style rayé et position maintenue
      full_width = TRUE,  # Table non étendue à la largeur complète
      font_size = 7
    )


```

## Regroupement les joueures par leur positions de jeu 

"Goalkeeper" , "Defender" , "Forward" , " Midfielder"
```{r Goalkeeper, message=FALSE, warning=FALSE, out.width='80%', results='hold'}


GoalKeepers <- subset(normaldt_RM_Players,normaldt_RM_Players$position=="Goalkeeper")

# Les noms de gardiens
# Load kableExtra
library(kableExtra)


kable(head(GoalKeepers[,1:5]), align = "l", caption = "Goalkeepers") %>%
  kable_styling(position = "left", full_width = FALSE)

```

```{r Defender, message=FALSE, warning=FALSE, out.width='80%', results='hold'}

# 
Defenders <- subset(normaldt_RM_Players,normaldt_RM_Players$position=="Defender")

# Les noms de defenders

kable(head(Defenders[,1:5]), align = "l", caption = "Defenders Table") %>%
  kable_styling(position = "left", full_width = FALSE)

```


Nous referons cette opération pour les milieux de terrain "MidFielders" et les défenseurs "Defenders"


```{r Midfielder, message=FALSE, warning=FALSE, out.width='80%', results='hold'}

# 
Midfielders <- subset(normaldt_RM_Players,normaldt_RM_Players$position=="Midfielder")

# Les noms de Midfielders
#kable(head(Midfielders[,1:5]), align = "l", caption = "Midfielders Table") %>%
# kable_styling(position = "left", full_width = FALSE)

```

```{r Forward, message=FALSE, warning=FALSE, out.width='80%', results='hold'}

# 
Forwards <- subset(normaldt_RM_Players,normaldt_RM_Players$position=="Forward")

# Les noms de Midfielders
#kable(head(Forwards[,1:5]), align = "l", caption = "Forwards Table") %>%
#kable_styling(position = "left", full_width = FALSE)

```


## Supprimer les colonnes non nécessaires pour chaque groupe 


Les critères principaux, les facteurs et les metriques pour chaque position sont différents à des autres, et ils sonts similaires dans certaines.

Par exemple : pour le gardien de but, ce sont les matchs sans encaisser de buts, les tirs bloqués, les buts encaissés, les passes en avant, les contributions réussies ou infructueuses du gardien. Pour les attaquants, ce sont les buts, les passes décisives, les duels remportés, les duels perdus, et ainsi de suite pour les milieux de terrain et les défenseurs.

Pour les gardiens nous pouvons noter : 

clean_sheets, blocked_shots, saves_made, saves_from_penalty, saves_made_caught, , saves_made_from_inside_box, saves_made_from_outside_box, saves_made_parried, goal_kicks, 
gk_successful_distribution, gk_unsuccessful_distribution, penalties_faced, penalties_saved,, penalty_goals_conceded, penalties_conceded, goal_assists, goal_kicks, putthrough_blocked_distribution, putthrough_blocked_distribution_won

alors nous supprimer les autres colones non nécessaires,mais pour vérifier si les colonnes correspondent à la position ou non, nous vérifions si toutes les lignes sont NA. Si c'est le cas, nous supprimons cette colonne

```{r GoalKeeper cleaning1, message=FALSE, warning=FALSE, out.width='80%', results='hold'}

print("Dimension Avant suppression")
dim(GoalKeepers)

remove_na_columns <- function(GoalKeepers) {
  # check kol columns is na lkol ou non 
  GoalKeepers <- GoalKeepers[, colSums(is.na(GoalKeepers)) < nrow(GoalKeepers)]
  return(GoalKeepers)
}


GoalKeepers<- remove_na_columns(GoalKeepers)

print("Dimension Aprés suppression")
dim(GoalKeepers)

```
Nous mettrons l'accent pour les gardiens sera principalement mis surles métriques essentielles concernent leur capacité à défendre le cage, les actions défensives, et les clean sheets alors on supprimer les colonnes de données qui ne sont pas utiles pour notre analyse : 

```{r GoalKeeper cleaning2, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}


print("Dimension Avant suppression")
dim(GoalKeepers)

delete_columns_if_exists<- function(GoalKeepers, columnsToDelete) {
  # si existe column -> put it in exisiting columns 
  existing_columns <- columnsToDelete[columnsToDelete %in% colnames(GoalKeepers)] # explicitement 
  
   # Suppression les colonnes souhaité 
  GoalKeepers <- GoalKeepers[, !(colnames(GoalKeepers) %in% existing_columns)]
  
  return(GoalKeepers)
}

columnsToDelete <- c("name","position","shirt_number", "backward_passes", "goal_assists", "goal_kicks", "goals_from_inside_box", "headed_goals", "home_goals", "offsides", "open_play_passes", "overruns", "putthrough_blocked_distribution", "putthrough_blocked_distribution_won", "recoveries", "red_cards_2nd_yellow", "second_goal_assists", "shots_on_target_inc_goals", "straight_red_cards", "substitute_off", "substitute_on", "successful_crosses_corners", "successful_crosses_open_play", "successful_dribbles", "successful_launches", "successful_open_play_passes", "successful_passes_opposition_half", "successful_passes_own_half", "successful_short_passes", "tackles_lost",
"through_balls", "times_tackled", "total_fouls_conceded", "total_fouls_won", "total_losses_of_possession", "total_passes", "total_successful_passes_excl_crosses_corners", "total_tackles", "total_touches_in_opposition_box", "total_unsuccessful_passes_excl_crosses_corners", "touches", "unsuccessful_corners_into_box", "unsuccessful_crosses_corners", "unsuccessful_crosses_open_play", "unsuccessful_dribbles", "unsuccessful_launches", "unsuccessful_layoffs", "unsuccessful_passes_opposition_half", "unsuccessful_passes_own_half", "winning_goal", "yellow_cards"
) 

GoalKeepers <- delete_columns_if_exists(GoalKeepers, columnsToDelete)


print("Dimension Aprés suppression")
dim(GoalKeepers)

```

Répéter le processus pour toutes les positions : 

- pour defenseurs: 

```{r Defenders cleaning1, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}

print("Dimension Avant suppression")
dim(Defenders)

remove_na_columns <- function(Defenders) {
  # check kol columns is na lkol ou non 
  Defenders <- Defenders[, colSums(is.na(Defenders)) < nrow(Defenders)]
  return(Defenders)
}


Defenders<- remove_na_columns(Defenders)

print("Dimension Aprés suppression")
dim(Defenders)

```

Supprimer les colonnes de données qui ne sont pas utiles pour notre analyse

```{r Defenders cleaning2, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}


print("Dimension Avant suppression")
dim(Defenders)


delete_columns_if_exists<- function(Defenders, columnsToDelete) {
  # si existe column -> put it in exisiting columns 
  existing_columns <- columnsToDelete[columnsToDelete %in% colnames(Defenders)] # explicitement 
  
   # Suppression les colonnes souhaité 
  Defenders <- Defenders[, !(colnames(Defenders) %in% existing_columns)]
  
  return(Defenders)
}


columnsToDelete <- c("name","position","shirt_number","away_goals", "backward_passes", "foul_attempted_tackle", "gk_successful_distribution", 
                     "goal_assists", "goal_kicks", "goals_conceded_inside_box", "goals_conceded_outside_box", 
                     "goals_from_inside_box", "goals_from_outside_box", "headed_goals", "home_goals", 
                     "key_passes_attempt_assists", "offsides", "open_play_passes", "overruns", 
                     "penalty_goals_conceded", "putthrough_blocked_distribution", "putthrough_blocked_distribution_won", 
                     "recoveries", "red_cards_2nd_yellow", "second_goal_assists", "shots_on_target_inc_goals", 
                     "straight_red_cards", "substitute_off", "substitute_on", "successful_corners_into_box", 
                     "successful_crosses_corners", "successful_crosses_open_play", "successful_dribbles", 
                     "successful_launches", "successful_layoffs", "successful_long_passes", "successful_open_play_passes", 
                     "successful_passes_opposition_half", "through_balls","yellow_cards")

Defenders <- delete_columns_if_exists(Defenders, columnsToDelete)


print("Dimension Aprés suppression")
dim(Defenders)

```
- pour milieux de terrains : il est essentiel de se concentrer sur les passes, les récupérations, les dribbles et leur capacité à influencer le jeu tant offensivement que défensivement, en facilitant la transition entre les deux phases.

```{r Midfielders cleaning1, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}

print("Dimension Avant suppression")
dim(Midfielders)

remove_na_columns <- function(Midfielders) {
  # check kol columns is na lkol ou non 
  Midfielders <- Midfielders[, colSums(is.na(Midfielders)) < nrow(Midfielders)]
  return(Midfielders)
}


Midfielders<- remove_na_columns(Midfielders)

print("Dimension Aprés suppression")
dim(Midfielders)

```

Supprimer les colonnes de données qui ne sont pas utiles pour notre analyse

```{r Midfielders cleaning2, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}


print("Dimension Avant suppression")
dim(Midfielders)


delete_columns_if_exists<- function(Midfielders, columnsToDelete) {
  # si existe column -> put it in exisiting columns 
  existing_columns <- columnsToDelete[columnsToDelete %in% colnames(Midfielders)] # explicitement 
  
   # Suppression les colonnes souhaité 
  Midfielders <- Midfielders[, !(colnames(Midfielders) %in% existing_columns)]
  
  return(Midfielders)
}


columnsToDelete <- c("name","position","shirt_number","aerial_duels", "aerial_duels_lost", "aerial_duels_won", "clean_sheets", "goal_kicks", "goals_conceded", "goals_conceded_inside_box", "goals_conceded_outside_box", "goals_from_inside_box", "goals_from_outside_box", "headed_goals", "home_goals", "offsides", "overruns", "penalties_conceded", "penalty_goals_conceded", "putthrough_blocked_distribution", "putthrough_blocked_distribution_won", "second_goal_assists", "substitute_off", "substitute_on", "tackles_lost", "total_clearances", "total_fouls_conceded", "total_losses_of_possession", "total_red_cards", "total_touches_in_opposition_box", "total_unsuccessful_passes_excl_crosses_corners", "unsuccessful_corners_into_box", "unsuccessful_crosses_corners", "unsuccessful_crosses_open_play", "unsuccessful_dribbles", "unsuccessful_launches", "unsuccessful_layoffs", "unsuccessful_long_passes", "unsuccessful_passes_opposition_half", "unsuccessful_passes_own_half", "unsuccessful_short_passes", "gk_successful_distribution", "yellow_cards", "straight_red_cards", "away_goals", "penalties_taken", "penalty_goals")

Midfielders <- delete_columns_if_exists(Midfielders, columnsToDelete)


print("Dimension Aprés suppression")
dim(Midfielders)

```
- pour les attaquants: 

```{r Forwards cleaning1, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}

print("Dimension Avant suppression")
dim(Forwards)

remove_na_columns <- function(Forwards) {
  # check kol columns is na lkol ou non 
  Forwards <- Forwards[, colSums(is.na(Forwards)) < nrow(Forwards)]
  return(Forwards)
}


Forwards<- remove_na_columns(Forwards)

print("Dimension Aprés suppression")
dim(Forwards)

```

Supprimer les colonnes de données qui ne sont pas utiles pour notre analyse .

pour les attaquants, il est crucial de maintenir des mesures appropriées pour leur performance offensive et leur capacité à marquer des buts:

```{r Forwards cleaning2, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}


print("Dimension Avant suppression")
dim(Forwards)


delete_columns_if_exists<- function(Forwards, columnsToDelete) {
  # si existe column -> put it in exisiting columns 
  existing_columns <- columnsToDelete[columnsToDelete %in% colnames(Forwards)] # explicitement 
  
   # Suppression les colonnes souhaité 
  Forwards <- Forwards[, !(colnames(Forwards) %in% existing_columns)]
  
  return(Forwards)
}


columnsToDelete <- c("name","position","shirt_number","backward_passes", "blocked_shots", "blocks", "corners_taken_incl_short_corners", 
"corners_won", "duels", "duels_lost", "forward_passes", "foul_attempted_tackle", 
"foul_won_penalty", "goals_conceded", "goals_conceded_inside_box", 
"goals_conceded_outside_box", "goals_from_inside_box", "goals_from_outside_box", 
"ground_duels", "ground_duels_lost", "ground_duels_won", "interceptions", 
"key_passes_attempt_assists", "open_play_passes", "overruns", 
"penalties_off_target", "penalty_goals_conceded", "putthrough_blocked_distribution", 
"putthrough_blocked_distribution_won", "recoveries", "second_goal_assists", 
"successful_corners_into_box", "successful_crosses_corners", "successful_crosses_open_play", 
"successful_dribbles", "successful_launches", "successful_layoffs", "successful_long_passes", 
"successful_open_play_passes", "successful_passes_opposition_half", 
"successful_passes_own_half", "successful_short_passes", "tackles_lost", 
"through_balls", "times_tackled", "total_clearances", "total_fouls_conceded", 
"total_fouls_won", "total_losses_of_possession", "total_successful_passes_excl_crosses_corners", 
"total_tackles", "total_touches_in_opposition_box", 
"total_unsuccessful_passes_excl_crosses_corners", "unsuccessful_corners_into_box", 
"unsuccessful_crosses_corners", "unsuccessful_crosses_open_play", "unsuccessful_dribbles", 
"unsuccessful_launches", "unsuccessful_layoffs", "unsuccessful_long_passes", 
"unsuccessful_passes_opposition_half", "unsuccessful_passes_own_half", "unsuccessful_short_passes"
)

Forwards <- delete_columns_if_exists(Forwards, columnsToDelete)


print("Dimension Aprés suppression")
dim(Forwards)

```
### Remplacement NA valeurs
- Nous remplacerons toutes les colonnes pour toutes les DATASET contenant des valeurs NA par 0, car nous savons que NA signifie 'Not Assigned' et dans notre cas, cela équivalent à 0. 


```{r NACleaning, echo=FALSE, warning=FALSE, out.width='80%', results='hold'}
  GoalKeepers[is.na(GoalKeepers)] <- 0
  Defenders[is.na(Defenders)] <- 0
  Midfielders[is.na(Midfielders)] <- 0
  Forwards[is.na(Forwards)] <- 0


```


## Nettoyage du dataset des matches RM

Nous allons nettoyer dataset qui contient les données sur les matches du REAL MADRID tout au long de la saison, mais sur lesquels nous nous concentrons uniquement sur les matches de compétition LaLiga, et suppression des colonnes inutiles.



```{r MatchesRM cleaning, message=FALSE, warning=FALSE, out.width='80%', results='hold'}


MatchesRM <- subset(MatchesRM, MatchesRM$Comp=="La Liga")


delete_columns<- function(MatchesRM, columnsToDelete) {
  # si existe column -> put it in exisiting columns 
  existing_columns <- columnsToDelete[columnsToDelete %in% colnames(MatchesRM)] # explicitement 
  
   # Suppression les colonnes souhaité 
  MatchesRM <- MatchesRM[, !(colnames(MatchesRM) %in% existing_columns)]
  
  return(MatchesRM)
}

columnsToDelete <- c("Date","Heure","Jour","Arbitre","Rapport de match","Notes","Capitaine","Formation","Formation Adverse")

MatchesRM <- delete_columns_if_exists(MatchesRM, columnsToDelete)



```

Dans cette partie, nous créons la variable cible ResultVar ("victoire", "match nul" ou "défaite") : 1 pour une victoire, 0 pour une défaite, et 2 pour un match nul, nous créons également notre deuxième variable cible, qui correspond à la différence entre les buts marqués et les buts encaissés (BM : buts marqués - BE buts encaissés). 

Mais avant cela, nous vérifierons que ces variables sont de type caractère ou non, puis nous les convertirons en Int.

```{r MatchesRM cleaning2, message=FALSE, warning=FALSE, out.width='80%', results='hold'}
# Verifier si les variables sont integer ou pas 

typeof(MatchesRM$BE)
typeof(MatchesRM$BM)

# Converting BE BM to Int 
MatchesRM$BE <- as.integer(MatchesRM$BE)
typeof(MatchesRM$BE)
MatchesRM$BM <- as.integer(MatchesRM$BM)
typeof(MatchesRM$BM)

# Creation les variabels cibles
# Assuming MatchesRM$Resultat contains "V", "D", or "N"
MatchesRM$Target1 <- ifelse(MatchesRM$Résultat == "V", 1, 
                        ifelse(MatchesRM$Résultat == "D", 0, 
                        ifelse(MatchesRM$Résultat == "N", 2,NA) ))

kable(head(MatchesRM[,4:13],6),caption = "Matches Real Madrid")


```



# Analyse de Données 

## Appliquer PCA/ACP (Analyse en Composantes Principales) 


## PCA Goalkeepers

L'Analyse en Composantes Principales (PCA) est utilisée pour réduire la dimensionnalité des données tout en conservant le maximum d'information possible.

#### Standardiser les données


```{r}
GK_PCA <- prcomp(GoalKeepers, scale. = TRUE)

```

#### Examiner les résultats de PCA

```{r}
summary(GK_PCA)

variances <- summary(GK_PCA)$importance[2,]
barplot(variances, main = "Variance expliquée par chaque composante principale", col = "lightblue", xlab = "Composantes principales", ylab = "Proportion de variance")

biplot(GK_PCA, scale = 0, cex = 0.6, col = c("red", "blue"), main = "PCA : Première et Deuxième Composantes Principales")


```

## Analyse de correlation goalkeeper 

###  

```{r}
GoalKeepers$performance_index <- GoalKeepers$saves_made * 0.4 + 
                                  GoalKeepers$aerial_duels_won * 0.2 +
                                 GoalKeepers$ground_duels_won * 0.2 -
                                  GoalKeepers$duels_lost *0.2 -
                                 GoalKeepers$penalty_goals_conceded *0.1 - 
                                  GoalKeepers$clean_sheets * 0.4 -
                                  GoalKeepers$goals_conceded * 0.3 
                                  


goalkeeper_performance_replicated <- rep(GoalKeepers$performance_index, nrow(MatchesRM))
combined_data <- cbind(MatchesRM[, c("xGA", "BE", "Target1")], performance_index = goalkeeper_performance_replicated)

cor_matrix <- cor(combined_data, use = "complete.obs")

print(cor_matrix)

plot(combined_data$performance_index, combined_data$BE, 
     xlab = "Performance Index", ylab = "xGA", 
     main = "Performance Index vs xGA")


corr_matrix <- cor(MatchesRM[, c("Target1", "BE", "xGA")], use = "complete.obs")
print(corr_matrix)
corrplot(corr_matrix, method = "circle", type = "upper", tl.cex = 0.8)


GoalKeepers$MatchID <- rownames(GoalKeepers)  # Add MatchID if missing

MatchesRM$MatchID <- rownames(MatchesRM)     # Add MatchID if missing


Goalkeeper_Analysis <- merge(GoalKeepers, MatchesRM[, c("MatchID", "Target1", "BE", "xGA")], by = "MatchID")
goalkeeper_metrics <- Goalkeeper_Analysis[, c("clean_sheets", "saves_made", "saves_made_from_inside_box", "saves_made_from_outside_box","catches","aerial_duels_won","goals_conceded")]
target_variables <- Goalkeeper_Analysis[, c("Target1", "BE", "xGA")]

# Calculate correlation
corr_matrix <- cor(goalkeeper_metrics, target_variables, use = "complete.obs")
print(corr_matrix)

# Visualize correlation


```



